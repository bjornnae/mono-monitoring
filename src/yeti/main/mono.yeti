module mono.mono;
load yeti.lang.io;
mp = load mono.parse;
mproc = load mono.proc;
log = load mono.logging;
mu = load mono.utils;

/*
This is the monitoring solution.

1. The logging solution (eventlog for example) puts log messages into a central log which is a text file with one message per line.
2. The monitoring solution periodically checks if new messages have arrived. The state of the monitored world is kept in an index 
3. New messages before previous monitor run and this are detected.
4. New messages are evaluated, if they lead to e.g. a state change an alert message will be sent.

StateLogMessage
stateLogObject
event
Index
*/


{
    getPropertyfile _ = "mono.properties",

	var storedIndexStruct = {var time = 0 is number, var indexedRowCount = 0 is number, var dbindex = [:] is hash<string, mp.stateLogObjType>},
	
	getCurrentTime _ = System#currentTimeMillis(),
	
	evLogAppend jsEvent = (
		data = mu.slurp ((mu.getProperties ( getPropertyfile () ))["mono.input.eventsfile"] ) ^ "\(jsEvent)";
		mu.spit ((mu.getProperties ( getPropertyfile () ))["mono.input.eventsfile"]) data
	),
	
	// Make index of logLst containing Event objects.
	makeIndex logLst = (
		var indexedRowCount = 0;
		dbindex = [:];
		for logLst do r:
			indexedRowCount := indexedRowCount + 1;
			indexKey = r.host ^ r.service;
			if indexKey in dbindex then (	
				if (dbindex[indexKey].time > r.time) then 
                    (log.logWarn "mono.makeIndex" "WARNING: Message is out of place. Refuse to use older message for indexing: \(r)")
				else dbindex[indexKey] := r
				fi );
			else dbindex[indexKey] := r;
			fi;
		done;
		{var time = getCurrentTime (), var indexedRowCount = indexedRowCount, var dbindex = dbindex}
		),
	
	// Save state to disk.	
	persistIndex dbIndexStruct = ( 
		dbEncoding = ''; 
		indexLines = list dbIndexStruct.dbindex;
		writeFile ((mu.getProperties ( getPropertyfile () ))["mono.db.indexfile"]) dbEncoding 
        (`putLines` 
            (map string 
                (map mp.stateLogObjectToJSON indexLines)));
		),	
		
	publishEv log event = push log event,
	
	// for each message in new events check if index is in baseline and if time is greater than baseline time.
	detectNewMessages baselineIndex logevents = (
		log.logDebug "mono.detectNewMessages" "Now start.";
		newEvents = array [];
		var rowCount = 0;
		var newCount = 0;
		for logevents do l:
			rowCount := rowCount + 1;
			idx = l.host ^ l.service;
			if idx in baselineIndex then
				if baselineIndex[idx].time < l.time then (
					//print "+";
					newCount := newCount + 1;
					push newEvents l;) 
				else 
					//print "-";
				fi;
			else
				newCount := newCount + 1;
				push newEvents l;
			fi;
		done;
		log.logDebug "mono.detectNewMessages" "\n<DEBUG:detectNewMessages> rowCount: \(rowCount), newCount: \(newCount).";
		newEvents),
			
	configurationExists? _ = (
        f = listDirectory false './';
        if contains? ( getPropertyfile () ) ( map (do d: d.name done) f ) then true
        else false
        fi),
        
    dbExists? _ = (
        f = listDirectory false './';
        dbfile = (mu.getProperties ( getPropertyfile () ))["mono.db.indexfile"];
        if contains? dbfile ( map (do d: d.name done) f ) then true
        else false
        fi
        ),
    
    createBaselineDB _ = (
        ll = map mp.jsStrTostateLogObject (mp.getLogLines ((mu.getProperties ( getPropertyfile () ))["mono.input.eventsfile"]));
        idx = makeIndex ll;
        log.logDebug "mono.createBaselineDB" "\(idx)";
        persistIndex idx
    ),
    
    matchConsumerActionsWithEvents consumers eventDict = 
        for consumers (do c : 
        if c.id == eventDict.id then 
            for eventDict.ev (do event :
            if (c.triggerOn event) then (c.actOn event) fi;
            done);
        fi;
        done
    ),
    
    doEval config consumers currentIndex stateMessageList is 'b -> 'a -> hash<string, mp.stateLogObjType> -> list?<mp.stateLogObjType> -> () = 
        case stateMessageList of 
		[]: ();
		_:  ( ev = mproc.evalEvents config currentIndex ( head stateMessageList ) ;
			matchConsumerActionsWithEvents consumers ev; 
			log.logDebug "mono.doEval" "Events: \(ev)";
            nextIndex = (makeIndex ( head stateMessageList :: ( list currentIndex ) )).dbindex ;
			doEval config consumers nextIndex ( tail stateMessageList ) ; // Watch tail recursion so that it doesn't eat up too much mem.
		     );
        esac,
        
    checkPrerequisites _ =   
        // todo: Check if mono.config exists. If not, throw a helpful error msg.
        // todo: Check if mono.db.indexfile exist. If not, create it and make a baseline from mono.input.eventsfile.
        if (not configurationExists? ()) then throw new java.io.IOException("Configuration file \(( getPropertyfile () )) is missing. Useless to proceed without it.")
        else
            if not dbExists?() then (
                log.logDebug "mono.checkPrerequisites" "Database file does not exist. Creating a new one.";
                createBaselineDB ();
                )
            else
                log.logDebug "mono.checkPrerequisites" "ALL prerequisites ok.";
            fi;
        fi,

    monitorNewStateReportMessages config consumers = (
        timeRunStart = getCurrentTime();
        checkPrerequisites ();
		currentStateIndex = makeIndex (mp.parseLogLines(mp.getLogLines ((mu.getProperties ( getPropertyfile () ))["mono.db.indexfile"]) ));
		stateMessageList = mp.parseLogLines(mp.getLogLines ((mu.getProperties ( getPropertyfile () ))["mono.input.eventsfile"]) );
		newStateMessages = detectNewMessages currentStateIndex.dbindex stateMessageList;
        doEval config consumers currentStateIndex.dbindex (list newStateMessages);
        makeIndex stateMessageList |> persistIndex;
		timeRunComplete = getCurrentTime();
		log.logDebug "mono.monitorNewStateReportMessages" "Elapsed time: \(timeRunComplete - timeRunStart)ms."
    )
        
    
}


